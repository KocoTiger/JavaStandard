	실습과제04
<<<<<<<OOP의 이해/Report제출>>>>>>>>
1. OOP(Object Oriented Programming):
 - OOP란 객체지향 프로그램이라는 뜻
 - 특징 : 추상화, 상속, 다형성, 캡슐화, 정보은닉 
 - 자바라는 언어 = 객체지향 프로그래밍으로 작성된 언어 
 - java가 등장 전 : 절차 지향 언어 사용 (절차 지향적 대표언어 : C언어)
 * 절차 지향 언어 : 프로세스 순서대로 작성 하면 순차적으로 이뤄지는 프로그램의 형태 
 - 프로그램 크기가 점점 커지고, 개인정보가 중시되기 시작,
   데이터를 정보보안적으로 보이지 않게 묶어서 서로 유기적으로 동작하게 되는 방법 고민.
   그렇게 객체 지향 방법의 JAVA 언어가 나오게 됨.

2. Object(객체):
 - 객체지향의 객체 : 
  * 사전적 의미 : '실제로 존재하는 것'
 - 우리가 tv와 같은 사물을 하나의 객체로 의미하는 것처럼
   객체지향의 경우, 무형적인(개념 or 논리) 것들도 객체로 간주.
 - 객체의 경우 가지고 있는 기능 and 속성에 따라 사용할 수 있는 부분이 다름. 
 ex> class = tv, 이 객체의 경우, 속성 + 기능의 집합. 
     class = 설계도, 이용하여 (종이), 
     tv(객체)에 대해서 class Tv {속성, 기능}이라는 구성요소로 객체를 만들어 내는 것을 의미.
 - 즉, 객체를 만들어 내는 부분이라는 것은
   1) class라는 종이에 
   2) 제목, 객체의 name 작성, 
   3) 속성인 멤버 변수(어떤 모습, 형태, 데이터, 속성)와 
   4) 기능인 메서드(행동)를 표현하여 작성하는 것

3. Class :
 - 앞서 , 객체에 대해 작성, 객체에 대한 설계도 = class라는 작성을 하였다. 
 - Class : 객체를 정의해놓은 것이며, 객체를 생성하는 데 사용.
 - Class 로부터 객체를 만드는 과정: 클래스의 instance화
 - 인스턴스화의 예시,
   ex> 1) 자판기 사용시, 자판기에서 누르는 부분을 인스턴스화 시킨 부분
          즉, 기계와 사람 사이에서 원활하게 작동시킬 수 있는 부분
       2) 사용자들이 인터넷을 원활하게 할 수 있게 만든 GUI도 인스턴스화.
 - class의 경우 매개변수+메서드가 작성이 되어있어, 서로 관련된 매게 변수들을 정의. 이들에 대한 작업을 수행하는 함수들을 함께 정의.
   변수와 함수들을 따로 작성하지 않고 원활하게 작성할 수 있도록 만들었으며, '사용자 정의 타입'클래스를 만들어서, 
   class Card {int number; String kind; int width = 100; int height =250;}
   1) class card는 정수형 숫자를 생성, 
   2) 참조 문자열 종류를 생성, 
   3) 정수형 가로 =100; 
   4) 정수 높이 250이라는 내용을 작성하여 다른 표현을 담당하는 class의 코드 블락에서 호출할 경우 사용할 수 있도록
   5) static을 사용하여 하나의 저장공간 안에 입력을 하고
   6) 클래스. 클래스 변수를 이용하여, 변수를 매번 새로 선언해줘야 하는 불편함과 복잡함이 없어지게 만듬.

4. abstraction(추상화):
 - 추상화란 메서드의 선언부만 작성, 실제 수행 내용은 구현하지 않은 추상 메서드를 선언하는 것
 - '미완성 설계도'라고도 함, (말 그대로 완성되지 못한 채로 남겨진 설계도) 
 - 추상 클래스의 경우, 상속을 통하여 자손의 클래스에 의해서만 완성이 될 수 있음
 - 새로운 클래스를 작성하는 데 있어서 바탕이 되는 조상 클래스로써 중요한 의미를 가짐.
 - 새로운 작성 클래스에 아무것도 없는 상태에서 시작이 되기보다는 완전하지 못하더라도 어느 정도 틀을 갖춘 상태에서 시작하는 것이 나을 것이기 때문에 
   작성된 메서드라고 할 수 있다.
 - 설계도에서 공통부분으로 표현될 설계도를 만들어놓고, 이 미완성 설계도를 이용해서 '오버 라이딩(Overriding)'하여 작성하면 된다. 

5. Generalization(일반화)/Inheritance(상속):
 - 앞에서 '오버 라이딩'이라는 단어가 나왔는데, 오버 라이딩이란, 상속이라는 단어에 대하여 먼저 설명을 해야 함 
 - 상속이라는 뜻 : 컴퓨터 공학적, 사전적 의미로 1) 기반 클래스, 2) 슈퍼 클래스, 3) 부모 클래스로부터 속성, 동작을 상속받을 수 있는 객체들 간의 관계를 구축하는			  방법 
		   위에 (부모, 더 넓은 의미로 조상)에게 물려받은 혈액형(속성)과 동작(우성 성질 동작)이 자식에게 물려받는 것이라고 이야기할 수 있다. 

   즉, 부모에게 물려받은 성질은 자식이 사용할 수 있으며, 자식이 수술을 받고 더욱 멋진 성질을 표현하게 될 경우는 부모에게 물려받은 메서드를 '오버 라이딩'할 수 있으며, 자식이 '오버 라이딩'한 성질을 부모가 가지고 있지 않기 때문에 당연히 사용할 수 없다는 것을 의미.
   그러나 이런 부분은 한정적인 부분을 의미한다. 
  - 일반화의 경우, 자식 클래스를 외부로부터 은닉하는 캡슐화의 일종으로 작용. 객체지향에서 오버 라이딩의 경우 부모와 동일한 구조에서 자식이 부모에게 물려받은 성	  질에서 어느 부분을 변경하여 출력하는 것이라는 말을 하였다. 
    
    이런 것처럼 일반화의 경우는 부모와 자식이 동일한 부분이 있으면 부모에게 표현을 하여 자식의 상태를 캡슐화하는 방법을 이야기하는 것이다. 
    즉, 자식의 상황이 어떤 모습인지 숨긴 체 부모의 성질만 나타내는 방법을 일반화라고 할 수 있다. 

6. Specialization(구체적):
 - 앞에서 자바의 상속에 관련하여 작성, 상속을 진행할 때 조상의 class객체의 이름을 super class로 지칭, 자손의 sub class들을 오버 라이딩하여 설정 가능, 이렇게 나   이렇게 나뉘는 하위 클래스들을 의미. 그리고 이러한 하위 클래스들은 특정한 도메인에 따라서 분류가 됨

7. Realization(실체화):
 - Object에서 작성한 것과 같이 객체지향에서는 객체를 '실제로 존재하는 것'이라는 사전적 의미 가짐. 즉, 객체지향에서는 물리적으로 존재하지 않는 것을 실체화하고    있다는 사실을 알 수 있다. 
 - 실체화 시킴으로써, 인터페이스 상의 상속을 만들어 낼 수 있으며, 추상화라는 상상의 단어를 구체적으로 구현할 수 있는 방법을 찾게 되는 이유가 되는 것.
 - 객체라는 언어의 단어가 실제로 존재하는 것이라는 의미는 중요성을 띄고 있다

8. Association(연관관계):
 - 연관관계는 이렇게 class들끼리 연관이 되어있다는 것을 의미. 
 - 앞에서 작성한 추상화, 상속 등 한 클래스와 다른 클래스 들의 관계가 연관 되어있다는 것을 의미

9. dependency(의존성):
 - 앞서 객체에 대하여 정의를 할 때 class는 설계도라는 이야기를 함 
 - 즉, 어떤 클래스에 어떤 객체를 넣어야 하는지, 객체를 어떻게 배치할 것인지에 대한 의사결정 
 - 이런 객체의 위치를 생각할 때, 변경이 되는 코드들은 함께 입력을 하고, 변경이 되지 않는 경우의 코드들은 별개로 입력을 하게 됨. 
   그렇게 변경에 대해서 초점을 맞춰서 서로 의존하는 방향에 따라서 입력을 하게 됨 
 - 수정하는 내용을 주로 작성하였는데, 작용하는 위치에 따라서도 서로 모집하여 함께 입력 가능. 
   1) 클라이언트의 요청을 받아주는 컨트롤러 객체, 
   2) 비즈니스 로직을 수행하는 서비스 객체 등 
   객체의 종류별로도 분류 가능. 이러한 객체들은 독립적으로 기능을 수행하기보다는 서로 의존하여 application의 기능을 구현하게 됨.

10. polymorphism(다형성):
 - '하나 이상의 형태를 갖는다'라는 의미를 가지고 있다. 
 - 다형성의 개념은 앞에서 이야기한 '오버 라이딩'과 이번에 처음 나온 단어인 '오버 로딩'이 대표적인 단어의 형태를 가짐. 
   일단, 다형성이라는 개념은 한 타입의 참조 변수로 여러 타입의 객체를 참조할 수 있게 만들었으며, 자세히 작성하자면 조상 클래스의 타입의 참조 변수로 
   자손 클래스의 인스턴스를 참조할 수 있게 만들었다는 것이다. 
   
 - 먼저 오버 로딩에 관하여 작성을 하고자 한다. 메서드가 같은 클래스 내에서 서로 구별될 수 있어야 하기 때문에 각기 다른 이름을 갖고,
   매개변수의 개수와 또는 타입이 다르면 같은 이름을 사용하여 메서드를 정의한다는 것이 오버 로딩의 정의이다.
   
 - 반환 타입은 오버 로딩을 구현하는데 아무런 영향이 없기 때문에 상관없이 사용해도 된다.
   long over 1 (int a, long b){return a+b;}와 
   long over 1 (long a, int b){return a+b;}의 경우
   이 둘이 현재 매개변수가 선언되었으며, 매개변수의 값에 의해 호출될 메서드가 구분이 될 수 있으므로 중복된 메서드가 아닌 오버 로딩으로 취급.
   
 - 그렇기 때문에 상속을 통하여 method를 받는 overriding과 overloding이 overloding의 경우는 변수의 이름이 동일, 다른 타입과 개수를 갖게 되는 하나 이상의 형태를   의미
   
 - overriding의 경우, 상속을 통하여 자식 메서드를 변화시켜 조상 메서드와 동일하지만 더 나아가 하나이상의 형태를 갖는다는 의미에서 다형성의 단어의 대표적인 단어   를 가짐.

ex> 자동차란 객체가 있을 경우자동차를 설계를 할 때 타이어 부분에 사용된 부분을 타이어 타입이라고 가정한다면  자동차의 타이어
    타입으로 한국 타이어와 금호 타이어가 있다고 한다면 어떤 타이어 타입을 사용하느냐에 따라 각 타이어의 성능은 다르게 나올 수 있다는 것이 
    다형성이라는 측면입니다. 그래서 한국, 금호 타이어는 자식 객체로써 객체를 부품화시킬 수 있다는 것입니다.

11. Encapsulation (정차은익, 정보은익):
   - 캡슐화는 객체와 기능, 메서드와 데이터 등을 위해 필요한 모든 자원을 프로그램 객체 내에 포함시켜 안전하게 변경하기 위해 보호하는 것이다.

   - 캡슐이라는 단어의 뜻은 일반적으로 밀폐된 용기를 가리키는데 밀폐시키고 보관하다. 거기에 +화 를 덧붙임으로 ~~ 하게 변화시킨다는 언어로 캡슐화가 씌었다고 생   각할 수 있다. 먼저 캡슐화를 시키는 방법 중에 한 가지는 현재 (22/02/08)에 public class Example과 public static void main(String [] args)를 사용할 때 
      보이던 public처럼 접근제어자를 이용하여 메서드와 데이터에 아무나 함부로 메서드와 데이터를 수정, 혹은 삭제 보는 것을 막아 정보를 은닉하는 것이 있다.
      접근제어자의 경우 4가지가 있는데 1) public 2) protected 3) default 4) private 로 멤버 변수나 멤버 메서드를 어떤 범위 내에서 접근하게 허락할 것인지를 정의해준다. 그렇기 때문에 public: 공통의 의미를 가지고 있는 public class를 쓰고 있는 현재 우리의 작성 폴더는 외부 어디서나 접근을 할 수 있다는 것을 알 수 있다.
      
      위에 작성된 접근제어자의 순서에 맞춰 접근 방법이 점점 적어지는데, protected의 경우 같은 패키지, 상속 관계만 접근 가능,
      default 같은 패키지에서만 접근 가능 , private의 경우 말 그대로 개인의 단어에 걸맞게 class안에서만 사용이 된다.
      만약 class앞에 별도의 접근제어자를 작성하지 않았으면 default의 접근제어자가 작성이 되어있기 때문에 접근제어자를 붙여주는 편이 좋다. 

출처
[https://lionpower.tistory.com/128]




==> Report 제출 condition
==> 제출 FileName : OOPPreport.txt
==> 편집기 : editplus
==> font: 돋음체, fontSize : 12, 글꼴 : Reqular
==> 문서/영구적성정/파일/설정 및 구문강조/자동줄바꿈/자동줄바꿈 check
==> File/인쇄설정/위, 아래,왼쪽, 오른쪽 여백 모두 1.0cm
==> A4용지 단면 2장 분량