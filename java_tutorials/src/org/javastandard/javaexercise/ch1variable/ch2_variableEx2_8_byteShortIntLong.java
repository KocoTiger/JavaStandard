/* p. 62~
#4.3 정수형 - byte, short, int, long
	정수형 4개의 자료형 (단위 바이트)
			byte	<	  short		<	int	<	 long
  			1				2			4			8
  	이중에서도 기본 자료형 (default data type) -> int
 
 
#정수형의 표현 형식과 범위
			S		n-1 비트
			
			S: 부호 비트 (양수는 0, 음수는 1)
			n : 타입의 크기 (단위: bit)
	모든 정수형은 부호있는 정수
	: 왼쪽의 첫번째 비트 : 부호 비트 (sign bit)사용
	: 나머지는 값을 표현 사용
			
			정수형의 표현방식(n비트)		종류					값의 개수
				0	n-1비트			0, 양수				2의 n-1승 개
				1	n-1비트			음수				2의 n-1승 개
  	:위의 범위 최대값에서 -1을 빼는 이유는 범위에 0이 포함되기 때문
  	
  	byte의 표현 형식 (8비트)		종류			값의 개수
  	00000000~01111111			0, 양수		2의7승개 (0~127)
  	10000000~11111111			음수			2의7승개 (-123~-1)
  	
  			8비트로 표현할 수 있는 정수의 개수 : 2의 8승개 (=2의 7승 + 2의7승)
  			8비트로 표현할 수 있는 분호있는 정수의 개수 : -2의7승 ~ 2의7승 -1(-128~127)
		[표 2-15 참고] 정수형의 표현 범위
 
#정수형의 선택기준
: int를 사용하자 (byte, short보다, 값의 범위가 작아서 메모리 절약되지만 오류가 많음)
: JVM의 피연산자 (operand stack)이 4byte단위로 저장하기 때문에 4byte보다 작으면 효율이 떨어짐
결론:
- 정수형 변수 선언 : int (범위 : 약 +-20억)
- 이를 넘으면 long을 사용



#정수형의 오버 플로우 (overflow) p.64~73 / 자바의 정석 책 참고
: 타입이 표현할 수 있는 값의 범위를 넘어선것 (에러가 발생하는게 아니라 예상했던 값이 안나옴)
: 오버플로우가 나지 않게 애초에 충분한 크기의 타입을 선택
[참고] 오버 플로우에서 1을 뺴면, TV의 채널을 증가시키다 마지막채널에서 더 증가시키면 
		첫번쨰 채널로 이동 -> 뒤로 감소시키면 -> 마지막 채널로 가는 것.과 비슷
		
			최대값 + 1 -> 최소값
			최소값 - 1 -> 최대값
#부호있는 정수의 오버플로우
		
		
		

 
 
 
 
 
 
 */













package org.javastandard.javaexercise.ch1variable;

public class ch2_variableEx2_8_byteShortIntLong {

	public static void main(String[] args) {
		// TODO Auto-generated method stub

	}

}
