/*p. 86~92
# 3. 연산자 (operator)

	1.1 연산자와 피 연산자
	# 연산자 (operator)
		+	더하기
		-	빼기
		*	곱하기
		/	나누기
	## 연산자가 연산을 수행하기 위해선 피 연산자가 필요 (피연산자, operand)
	## 피연산자 : 상수, 변수, 식을 사용 가능
	
			x		  +		  3
		  피연산자		 연산자	피연산자
	## 연산자는 피연산자로 연산을 수행하고 나면 항상 결과값을 반환한다.
	
	1.2 식과 대입연산자
	# 식 (expression)
	: 연산자와 피 연산자를 조합하여 계산하고자 하는 표현
	# 식을 평가 (evaluation)
	: 식을 계산하여 결과를 얻는 것
				4 * x + 3
	: 작성한 식을 프로그램에 포함시키려면, 식의 끝에 ;를 붙여서 하나의 문장으로 만들어야함
				4 * x + 3;
	: 예를 들어 변수 x값이 5일때,
				4 * x + 3;
			->	4 * 5 + 3;
			->	23;				//결과를 얻었지만 쓰이지 않고 사라진다.
 	: 식이 평가되어 23이라는 결과를 얻었지만, 이 값이 어디에도 쓰이지 않고 사라지기 떄문에
 	  대립 연산자 =를 사용하여 변수와 같이 값을 저장할 수 있는 공간에 결과를 저장해야함
 	  			y = 4 * x + 3;
 	  		->	y = 4 * 5 + 3;
 	  		->	y = 23;			//식의 평가결과가 변수 y에 저장
 	: 다음에는 변수 y에 저장된 값을 다른곳에 사용하거나 화면에 출력, 의미있는 결과를 얻음
 				y = 4 * x + 3;
 				System.out.println();		//변수 y의 값을 화면에 출력
 	: 만일 식의 평가 결과를 출력하기만 원할 뿐, 이 값을 다른 곳에 사용하지 않을 것이라면
 	  다음과 같이 변수에 저장하지 않고 println메서드 괄호()안에 직접 식을 써도됨.
 	  			System.out.println(4 * x + 3);
 	 		->	System.out.println(23);		//23이 화면에 출력
 	1.3 연산자의 종류
 	
 	  종류					연산자					설명
 	산술 연산자				+ - * / % << >>			사칙연산과 나머지 연산 (%)
 	비교 연산자				> < >= <= == !=			크고 작음과 같고 다름을 비교
 	논리 연산자				&& \\ ! & \ ^ ~			그리고(AND)와 또는(OR)으로 조건을 연결
 	대입 연산자				=						우변의 값을 좌변에 저장
 	기타					(type) ?: instanceof	형변환 연산자, 삼항 연산자, instanceof 연산자
 	### [참고] type은 형 변환 연산자를 의미
 	### 연산자는 크게 산수, 비교, 논리, 대입 4가지로 나눔
 	
 	# 피연산자의 개수에 의한 분류
 	: 피연산자의 개수에 따라 단항(피연산자 개수:1), 이항(피연산자 개수:2), 삼항(피연산자 개수:3) 연산자로 부름  
 	: 대부분 이항 연산자
 	: 삼항 연산자는 오직 -> ?:
				   -	3				-	 	5
				부호연산자	-			뺄셈 연산자 -
	
				   -	3		-	 	5
				뺄셈의 피연산자	-3		뺄셈의 피연산자 5
			부호연산자의 피연산자 3
  
  	: 단항 연산자 : -숫자 음수			+숫자 양수부호
    : 이항 연산자 : 뺄셈  피연산자 - 피연산자 			더하기 피연산자 + 피연산자 
  	: 연산자의 우선 순위도 있다.
  	
  	1.4 연산자의 우선순위와 결합 규칙
  	: 식에 사용된 연산자가 둘 이상인 경유, 연산자의 우선순위에 따라 연산순서 결정
  	: *, / (곱하기, 나누기)			vs			+, - (더하기, 빼기)
  				먼저									나중
  	
  			5		+		3		*		4
  			값 : 17
  	## 이처럼 연산자의 우선순위는 대부분 상식적인 선에서 해결
  	
  			식							설명
  	-x + 3							단항 연산자가 이항 연산자보다 먼저.
  	x + 3 * y						곱, 나누기가 뺴기, 더하기 보다 먼저
  	x + 3 > y - 2					비교연산자 > 보다 산술연산자 + - 가 먼저
  	x > 3 && x < 5					논리연산자 &&보다 비교연산자가 먼저 수행
  	
  	result = x + y * 3;				대입연산자는 연산자 중에 제일 우선순위가 낮음
  									그래서 우변의 최종 결과가 변수 result에 저장
  	
  	## 아직 배우지 않은 연산자들
  			식							설명
  	x << 2 + 1						쉬프트 연산자 <<
  									덧셈보다 우선순위가 낮음
  									x << (2 +1)
  	data & 0xFF == 0				논리연산자 & 는 비교연산자 ==보다 우선순위가 낮음
  									비교연산 후 논리연산 수행
  									data & (0xFF == 0)
  	x < -1 \\ x > 3 && x < 5		논리연산자 중 AND=&&가 OR(\\)보다 먼저임.
  									수식에 AND OR이 함께 사용되는 경우 다음과 같이 괄호를 사용해서 우선
  									순위를 명확히 하는 것이 좋다
  									x < -1 \\ (x > 3 && x < 5)
  	
  	## 우선순위, 보통 상식적인 선에서 해결
  	   우선순위가 확실치 않을 경우, ()로 묶어주기.
  	[참고] ()는 연산자가 아님. 연산자의 우선순위를 임의로 지정할때 쓰는 기호

  	# 연산자의 결합 규칙
  	: 하나의 식에 같은 우선 순위 연산자들이 여러개 있을 경우, 아무거나 먼저 처리하는게 아니라
  	  나름대로의 규칙을 가지고 있다. '연산자의 결합 규칙'이라고 함
  	: 연산자마다 결합규칙이 다르지만, 대부분 왼쪽에서 오른쪽
  	  단항 연산자와 대입연산자만 오른쪽에서 왼쪽순서로 연산 수행.
  	    ---->								 <-------
  	  3 + 4 - 5								x = y = 3
  	     7										  3
  	        2								  3
  	        								x = 3; y=3; 을 위처럼 쓸수 있음
  	        								
  	##정리
  	1. 산술 > 비교 > 논리 > 대입. 		대입은 제일 마지막에 수행
  	2. 단항(1) > 이항(2) > 삼항 (3).	단항 연산자의 우선순위가 이항 연산자보다 높다
  	3. 단항 연산자와 대입 연산자를 제외한 모든 연산의 진행방향은 왼쪽에서 오른쪽
	p. 91 [표 3-4] 연산자의 우선 순위와 결합 규칙 참고

  	[참고] instanceof는 객체의 타입을 확인하는데 사용되는 연산자
  	
  	1.5 산술 변환 (usual arithmetic conversation)
  	- 이항연산자 : 두 피연산자의 타입이 일치해야 연산 가능!
  			  : 타입 일치 -> 연산 실행 (int타입 + float타입 => 둘다를 int나 float로 일치 후 연산)
  	ex>
  			  int i = 10;
  			  float f = 20.0f;
  			  
  			  float result = f + (float) i;		//형변환으로 두 피 연산자의 타입을 일치
  		## 대부분, 두 피연산자의 타입 중에서 더 큰 타입으로 일치!
  				 이유 : 작은 타입으로 형변환 시, 값이 손실 가능성 있음.
  		## 큰 타입으로 형 변환시 자동으로 형변환 되므로 형변환 연산자를 생략 가능.
  			ex>
  				float result = f + i;		//큰 타입으로 형변환시, 형변환연산자 생략가능
  		이처럼, 연산 전에 피 연산자 타입의 일치를 위해 자동 형변환 되는 것을
  		산술변환, 일반 산술 변환이라고 한다.
  		이항 연산만이 아니라, 단항 연산에서도 일어난다.
  		
  		##산술 변환 규칙
  			1> 두 피연산자의 타입을 같게 일치 시킨다.  (보다 큰 타입으로 일치)
  				long + int -> long + long -> long
  				float + int -> float + float -> float
  				double + float -> double + double -> double
  			2> 피연산자의 타입이 int보다 작은 타입이면 int로 변환
  				byte + short -> int + int -> int
  				char + short -> int + int -> int
  		[참고]모든 연산에서 '산술 변환'이 일어나지만, 쉬프트 연산자 <<, >> , 증감연산자 ++, -- 는 예외
  		
  		첫번째 규칙 : 피연산자의 값손실을 최소환
  		두번째 규칙 : 정수형의 타입인 int가 가장 효율적으로 처리할 수 있기 때문
  				 : int보다 작은 타입, char나 short의 표현범위가 좁아서 연산중에 오버플로우가 발생할
  				   가능성이 높기 때문에 만들어짐.
  				   
  		중요! 주목할 점! 연산결과의 타입!
  			#정수형 int : 실수형이 아니기 때문에 소수점 아래는 다 버림.
  					int			int		->		int
  					 5      /	 2		->		 2
  			#2.5라는 결과를 얻기 위해선, float와 같은 실수형으로 한쪽을 형변환 시켜야함 (자동형변환 됨)
				int/(float) int	->	int	/ float	 ->	float / float	-> float
  				5  /(float)  2  ->   5  /   2.0f -> 5.0f / 2.0f		-> 2.5f
  		
  		## 일반 산술 변환이란? 연산 수행전에 발생하는 피연산자의 자동 형변환
  			1> 두 피연산자의 타입을 같게 일치시킨다. (보다 큰 타입으로 일치)
  			2> 피연산자의 타입이 int보다 작은 타입이면 int로 변환된다.
  		
  		
  			
  	
  	
  	
  	
  	
 */





package org.JavaStandards_Ch3;

public class Operator1_1 {

	public static void main(String[] args) {
		
		
		
		
		
		
	}

}
